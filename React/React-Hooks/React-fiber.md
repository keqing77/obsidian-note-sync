> [!info] fiber 是纤程，比线程更精细，表示对渲染线程实现更精细的控制

- fiber 是一种新的**数据结构** ，`react fiber`使得`diff`阶段有了被保存工作进度的能力
- 在数据更新的时候, react 的 diff 操作 (找出新老组件真正变化的部分 ) 相当耗时 , `js占据主线程`去做比较，`渲染线程`便无法做其他工作，用户的交互得不到响应，我们要找到前后状态变化的部分，**必须把所有节点遍历**, 所以便出现了`react fiber`

**递归遍历虚拟dom树被打断就得从头开始，为什么有了react fiber就能断点恢复呢?**
- react fiber这种数据结构使得节点可以回溯到其父节点，只要保留下中断的节点索引，就可以恢复之前的工作进度
- 在 旧的 树操作, 每个节点只有 单独一个指针 执行 子节点, 如果中断 无法根据指针寻找父节点 , 而在新的 fiber 架构中, **每个节点有三个指针：分别指向第一个子节点、下一个兄弟节点、父节点。这种数据结构就是fiber**，
- 它的遍历规则如下：
	- 从根节点开始，依次遍历该节点的子节点、兄弟节点，如果两者都遍历了，则回到它的父节点；
	- 当一个节点的所有子节点遍历完成，才认为该节点遍历完成；


**在 React 中, 视图更新背后做了这些事情**
1. 调用 setState 后, 会自顶向下重新渲染组件，自顶向下的含义是，**该组件以及它的子组件全部需要渲染**；
2. 父组件状态更新了, 所有的子组件都得跟着重新渲染, 这非常消耗性能, 并不能像 vue 等框架一样做到组件级别的颗粒度更新

**采用虚拟 DOM视图更新所做到操作**
1. 组件渲染生成一棵新的虚拟dom树；
2. 新旧虚拟dom树对比，找出变动的部分；（也就是常说的diff算法）
3. 为真正改变的部分创建真实dom，把他们挂载到文档，实现页面重渲染；
4. React 和 Vue 不同的是 响应式实现原理不同, vue 能做到更细的颗粒度


## Q&A

### fiber 解决了什么问题(工作机制) ?
- 使用react fiber时，并没有减少更新所需要的总时间 , 但能在单位时间内浏览器可以获得更多时间渲染, 也就是在一秒内获得更多的动画帧 , 从而使得应用的交互响应更为流畅
![[Pasted image 20230206104550.png]]


### 为什么没有 vue-fiber ?

- vue 的响应式原理 实现得更为巧妙, 可以做到组件级别的颗粒度更新, 不存在 react 的这个 问题 , 自然也没有这个需求
- vue实现精准更新也是有代价的，一方面是需要给每一个组件配置一个“监视器”，管理着视图的依赖收集和数据更新时的发布通知，这对性能同样是有消耗的；
- 另一方面vue能实现依赖收集得益于它的模版语法，实现静态编译，这是使用更灵活的JSX语法的react做不到的。
- 在react fiber出现之前，react也提供了PureComponent、shouldComponentUpdate、useMemo,useCallback等方法给我们，来声明哪些是不需要连带更新子组件。
