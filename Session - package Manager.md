## node_modules

### 依赖嵌套🪆
npm2 的 node_modules 是嵌套的， 多个包之间难免会有公共的依赖，这样嵌套的话，同样的依赖会复制很多次，这直接导致磁盘空间的急速膨胀, 直观的感受就是`npm install`的时候需要等待非常长的时间，或者超时，同时吃掉你一部分的磁盘空间（甚至以GB为单位😭） 

除此之外导致的一个最致命问题是 `windows` 的文件路径最长是 260 多个字符，这样嵌套是会超过 windows 路径的长度限制的。

### 嵌套拍平（扁平化）和 locke 锁文件
当时npm并没有解决这个问题，所以yarn就诞生出来并解决这个问题，并且npm在随后的版本中也跟进了这个feture. (btw, lock锁文件可以锁定依赖版本也是yarn最先实现的，npm也在随后跟进了)


### 幽灵依赖👻
但是这个方案并没有完全解决问题，扁平化的方案也有相应的问题。

最主要的一个问题是幽灵依赖，也就是你明明没有声明在 dependencies 里的依赖，但在代码里却可以 require 进来。

这个也很容易理解，因为都铺平了嘛，那依赖的依赖也是可以找到的。

但是这样是有隐患的，因为没有显式依赖，万一有一天别的包不依赖这个包了，那你的代码也就不能跑了，因为你依赖这个包，但是现在不会被安装了。

这就是幽灵依赖的问题。

而且还有一个问题，就是上面提到的依赖包有多个版本的时候，只会提升一个，那其余版本的包不还是复制了很多次么，依然有浪费磁盘空间的问题。

### pnpm
pnpm 是一个 Node.js 包管理器，它可以用来代替 npm 或 Yarn。pnpm 支持 Monorepo，可以通过 `pnpm-workspace.yaml` 文件在多个子项目之间共享依赖项。pnpm 的 monorepo 特性和 Yarn Workspaces、Lerna 类似，都是为了解决多个相关项目共享代码和依赖项的问题。

pnpm 通过共享依赖来减少磁盘空间的使用，并且通过并行安装依赖项来提高安装速度。

。它由 npm/yarn 衍生而来，但却解决了 npm/yarn 内部潜在的 bug，并且极大了地优化了性能，扩展了使用场景。

以下是 pnpm 的一些优缺点：

优点：

-   磁盘空间使用更少：pnpm 通过共享依赖项来减少磁盘空间的使用。如果多个项目都使用了同一个依赖项，那么这个依赖项只会被下载一次，并且被共享到这些项目中。
-   更快的安装速度：pnpm 支持并行安装依赖项，这样可以更快地完成安装。pnpm 还可以缓存已经安装的依赖项，这样可以避免重复下载。
-   更好的 monorepo 支持：pnpm 支持 monorepo 环境，并且可以通过共享依赖项来减少重复的安装。这样可以使 monorepo 环境更加高效。

1.  **安装速度最快**（非扁平的包结构，没有`yarn/npm`的复杂的扁平算法，且只更新变化的文件）
2.  **节省磁盘空间** （统一安装包到磁盘的某个位置，项目中的`node_modules`通过`hard-link`的方式链接到实际的安装地址）

缺点：

-   相对较新：pnpm 是一个比较新的包管理器，相对于 npm 和 Yarn 来说还没有那么成熟和稳定。可能存在某些不兼容或者 bug。
-   可能需要一些配置：pnpm 在使用过程中可能需要一些额外的配置，以便更好地支持 monorepo 环境或者与其他工具协同使用。



### Monorepo
如果你打算把前后端都放在同一个 repo 里面，可以考虑使用 monorepo 工具来
进行依赖管理和复用。

monorepo 是指将多个相关的项目（如前端、后端、测试等）放在一个仓库中进行管理，通过共享依赖来提高开发效率和代码可维护性。在 monorepo 中，可以将共享的代码或库放在一个单独的目录中，并在各个子项目中引用它们，避免了重复的代码和依赖管理。

一些常用的 monorepo 工具包括：

-   Lerna：一个 JavaScript 工具，用于管理具有多个软件包的 JavaScript 项目的工作流程。
-   Yarn Workspaces：Yarn 自带的 monorepo 工具，可以将多个项目共享依赖和配置。
-   Nx：一个集成了 Lerna 和 Yarn Workspaces 的 monorepo 工具，用于构建和测试 Angular、React 和 Node.js 应用。

使用 monorepo 可以简化项目的管理和维护，并且提高代码复用性。


当一个项目包含多个独立但相关的组件时，monorepo是一种组织和管理代码的方法。它允许将这些组件统一放在一个版本控制库中，从而简化了协作和共享代码的过程。

具体来说，monorepo是一个单一的代码库，其中包含多个项目或包。每个项目或包都可以有自己的目录结构、配置和依赖项，但它们共享相同的版本控制和构建/部署流程。这意味着如果你需要修改一个组件，你可以很容易地找到它，并且可以在同一个提交中修改多个组件。

Monorepo的优点包括：

-   代码共享：多个项目或包可以共享代码，从而减少了代码的重复编写，提高了代码质量和一致性。
-   更好的可维护性：所有代码都在同一个版本控制库中，便于代码重构、迁移和维护。
-   更好的协作：多个开发人员可以轻松地在同一个项目中合作开发，共享代码和知识。
-   更快的构建和测试：可以在一个代码库中统一管理和构建所有组件，从而提高了构建和测试的效率。

当然，monorepo并不适用于所有情况。如果你的项目非常大或者包含非常不相关的组件，那么分离成多个库可能更好。

#### 缺点：
编译/ 依赖安装时间变长  ->  按需编译/ 手动指定编译项目
Git记录混乱 -> 所有人的commit都在一个线性历史， 需要团队的规范化处理，做好git commit检验
项目隐私性 -> 如果需要对某些仓库进行权限管理就需要慎用了， 实现不了对某个项目施加细粒度的权限控制
对IDE负担加重， 加载几十个项目的代码需要一点时间和一点点内存

### example


> 使用`pnpm`管理的一个`monorepo`例子

```json
your-monorepo/  
├── package-a/  
│   ├── package.json  
│   ├── node_modules/  
│   ├── package-a/  
│   │   ├── index.js  
│   │   ├── main.js  
│   │   ├── package-a.js  
│   │   ├── package-a-global.js  
│   ├── package-b/  
│   │   ├── package.json  
│   │   ├── node_modules/  
│   │   ├── package-b/  
│   │   │   ├── index.js  
│   │   │   ├── main.js  
│   │   │   ├── package-b.js  
│   │   │   ├── package-b-global.js  
├── package-c/  
│   ├── package.json  
│   ├── node_modules/  
│   ├── package-c/  
│   │   ├── index.js  
│   │   ├── main.js  
│   │   ├── package-c.js  
│   │   ├── package-c-global.js  
├── package-d/  

```

这个示例 monorepo 包含多个包，每个包都有自己的 `package.json` 文件和自己的 node_modules 目录。此外，每个包还拥有一些共同的依赖项，这些依赖项存储在共同的 node_modules 目录中。

使用 pnpm，开发人员可以在单个命令中安装整个 monorepo，并自动安装所有依赖项。此外，由于 pnpm 使用缓存，因此安装过程非常快，并且可以节省磁盘空间



####  解决问题
- 解决代码复用问题
- 开发流程统一
- 高效管理多项目/包， 节省代码体积



### 参考链接
1. https://juejin.cn/post/7184392660939964474?share_token=53ea67e2-d1c6-45e4-ad90-ec26b139e8ca
2. https://juejin.cn/post/6932046455733485575
3. https://juejin.cn/post/7099090192887185439?share_token=1e47d0b5-9dc0-45e6-95ab-3d475212d132
4. https://zhuanlan.zhihu.com/p/77577415