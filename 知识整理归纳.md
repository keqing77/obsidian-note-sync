```ts

const rea = [  
'1slo5q0g99ss1e5cfctkdj3ni6',  
'63b4th825kkloal0u0b677vahs',  
'2fb06dqab95hci46dgldph0382',  
'67itphfaasklu3uo5htb953r04',  
'3b13kuk1s7s18c5olh3t3o2jmt',  
'4ccqj6b2b9439q7tdctvmlrdne'  
];  
  
const rca = [  
'1p48kcl0ftem2iee52ih34034',  
'5j47i153ecsr36fmsut62oe1c6',  
'6q3ro4100mm73lp5pbrq7rdj5h',  
'4pe9tnm1ob1g9e94a08itldueg',  
'49jott98s687hs7979ic5dm0l0',  
'2i429vaqutmpits0itbluc4fh3'  
]

user_metadata = {

}

// auth0 management user

app_metadata = {
	 "lockeId": "3617576e-0025-4628-aafb-29511e5ea8c7",
	 hasSourceChecked: {
		 rca : true
	 }
}

// locke-demo profile

'custom:source_name': sourceInfo.source_name
'custom:source_id': sourceInfo.source_id


```


-client   传入不同的  client_ _ID
	- 1. client = RCA
		- hasSourceCheck = ✅     
			- end
		- hasSourceCheck = ❌    
			- get & update UserSource , find custom source id & name in auth0 sides
			- set hasSourceCheck to `true`
	- 2. client = REA
		- hasSourceCheck = ✅    end
		- hasSourceCheck = ❌   
			- get & update UserSource , find custom source id & name in auth0 sides
			- set hasSourceCheck to `true`

## 知识碎片

- 一句话理解 React Server Component：将原有的所有客户端组件根据依赖分割为两部分：
    - 依赖数据源（比如数据库、fs）的组件（服务端组件）
    - 依赖状态（比如state、props）的组件（客户端组件）
- 前端进阶
    - rxjs ，数据处理
    - b/s 中的 b 比如 performance, navigator 对象和各种 linstener 等等
    - 动画，GL ，图表等等
    - sass,less -> css
    - 常用打包构建工具原理, rollup,webpack,vite
    - 如何使用 js/ts 代码调用打包函数进行打包(因为涉及到 ci 或者发布第三方包，所以需要如此)
    - CDN 图床工具，前端配置化中心，发布平台，按需灰度
    - 做自己的产品经理，从前端开发工作中提炼出需求



## 代做清单

- [ ] update Portfolio
- [ ] update Blog
- [ ] update publish
	- [ ] Front-end Interviews & notes
	- [x] 2023 React 生态
	- [ ] VsCode 配置分享 (snippets, plugins, config)
	- [ ] mac 软件分享
	- [ ] windows软件分享
	- [ ]  Arc 浏览器分享
	- [ ] 前端资源分享 (资源，大牛，项目，书籍，博客，播客，平台)
	- [ ]  2023 年终总结

### idea
- [ ] 闲来茶否 - 五行生肖
- [ ] 流浪方舟
- [ ] react - interview - quiz
- [ ] react-challenges 
- [ ] type-challenges 刷题记录
- [ ] vue-challenges 刷题记录


## Skill Checklist

### Authorization & Authentication
- [ ] Oauth2.0 Authorization flow & PKCE
- [ ] OIDC
- [ ] SAML
- [ ] SSO
- [x] JWT
	- 一个JWT的结构如下 `xxxxx.yyyyy.zzzzz` , 一般使用base64编码传输
	- example:  ```eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c```
	- 在这个示例中，JWT由三部分组成：
	1. Header：`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9`
	2. Payload：`eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ`
	3. Signature：`SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c`


### AWS
- [ ]  Lambda
- [ ]  CloudFront
- [ ]  DynamoDB
- [ ]  CloudWatch
- [ ]  Kinesis
- [ ]  Cognito
- [ ]  S3
- [ ]  Route53
- [ ] KMS
- [ ] SNS SQS
- [ ] SES
- [ ]  IAM
- [ ] ApiGateway
- [ ] Athena
- [ ] EventBridge

### Infrastructure
- [ ] Shepherd 
- [ ] Stack up 
- [x]  BuildKite 
- [x]  PagerDuty 
- [x]  git & Github 
- [x] NewRelic 
- [x]  Splunk 
- [x] Big query


### probation

项目上的：
galaxy:  Locke/locke-logs-audit  locke-account-settings-ui locke-events-forwarder  Locke/locke-tealium-tracker
system health rating : https://git.realestate.com.au/rea-systems/rea-systems-data/pull/4136
- LK-3080   add custom title for LAS and Locke-demo
- LK-3004  add locke-admin-management-api’s pagerduty
- LK-3101   fix slack channel name from locke to locke-help
- LK-3092  Identify how we can alert when the 403 cookie issue occurs

最近学习：
练习口语，背单词 -> 业余参加英语角练习口语， 背诵常用英语片段和工作上一些常见的缩写， 刻意练习 rehearsal 
Oauth2.0 + OIDC ， 订阅了Auth0和Okta的技术频道，了解主流常见的鉴权方案背后的一些实现原理和工作机制， 但还没完全理解透彻
AWS的一些服务使用，做卡时候涉及一些相关的服务，边做边查边学， CloudWatch监测， S3对象存储，WAF防火墙， CloudFront CDN缓存 和 Lambda 函数等等， 还需要更多业务上的实操
学习了一下 rx.js ， 启发了一些关于异步事件处理的思路
最近在学习并开发一个Next.js 13 App Router 的项目,  应用了 React Server Component 和 Turbopack 最新技术和工具 ， React18之前只有客户端组件，想要在服务器渲染完整的 html模板只能使用一些SSR方案， 如使用内置API - `const html = renderToString(reactNode)` 或者Next.js等SSR框架， 现在可以根据依赖分割成（client components）客户端组件和服务端组件RSC(react server components) ， 依赖数据源（比如数据库、fs）的组件可以使用服务端组件， 而依赖状态（比如state、props）的组件则是客户端组件

查缺补漏， 归纳整理自己的笔记， 知识输出